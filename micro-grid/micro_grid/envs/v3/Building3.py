from micro_grid.envs.v2.Ambient2 import Ambient
from micro_grid.envs.v2.Solar2 import Solar
from micro_grid.envs.v1.WindGenerator import WindGenerator
from micro_grid.envs.v2.Battery2 import Battery
from micro_grid.envs.v1.EnergySource import Energysource
import queue as qu
import random


class Building:
    """Class representing a building in the microgrid, can have energy sources and a battery, has inhabitants and a
    """

    def __init__(self, energy_sources: list, battery: Battery, inhabs: int, ambient: Ambient):
        self.energy_sources = energy_sources
        self.battery = battery
        if(inhabs < 0):
            inhabs = 0
        if(inhabs > 3):
            inhabs = 3
        self.inhabs = inhabs
        self.ambient = ambient
        self.hourly_power_given = 0
        self.queue = qu.Queue()

    def sum_sources(self, ambient=None) -> float:
        """Sums up all of the available power generated by available energy sources

        Args:
            ambient (_type_, optional): The Ambient of the environment. Defaults to None.

        Returns:
            float: The sum of available power generated by the building
        """
        if(ambient is None):
            ambient = self.ambient
        sum = 0
        for source in self.energy_sources:
            if type(source) is Solar or type(source) is WindGenerator:
                sum += source.get_power(ambient)
        return sum

    # Asks how much power is ready to be send
    def get_power(self, ambient=None) -> float:
        """Sums up the total power available in the building

        Args:
            ambient (_type_, optional): The Ambient of the environment Defaults to None.

        Returns:
            float: The total power available at the building
        """
        if(ambient is None):
            ambient = self.ambient
        sum = self.sum_sources(ambient)
        sum += self.battery.get_fuel()
        return sum

    def consume_power(self, power: float, ambient=None) -> float:
        """Drains power from the building
        If there is not enough power drains everything that is available
        Args:
            power (float): Amount of power to be drained
            ambient (_type_, optional): The Ambient of the environment. Defaults to None.

        Returns:
            float: The power that was taken from the house.
        """
        if(ambient is None):
            ambient = self.ambient
        sum = self.sum_sources(ambient)
        if sum < power:
            sum += self.battery.get_power(power-sum)
        return sum

    def consume_percentage(self, percentage: int, ambient=None) -> float:
        """Consume a percentage of the available power

        Args:
            percentage (int): Percentage either -1 0 or 1
            ambient (_type_, optional): The Ambient of the environment. Defaults to None.

        Returns:
            float: consumed power
        """
        if(ambient is None):
            ambient = self.ambient
        power_availabe = self.get_power(ambient)
        if percentage == 0:
            return self.consume_power(0, ambient)
        elif percentage == 1:
            return self.consume_power(power_availabe, ambient)
        else:
            return self.consume_power(power_availabe * 0.5, ambient)

    def power_consumption(self, ambient=None) -> float:
        """The power consumption of the building in a timestep

        Args:
            ambient (_type_, optional): The Ambient of the environment. Defaults to None.

        Returns:
            float: The consumption of the building at the given time step
        """
        if(ambient is None):
            ambient = self.ambient
        consumption_per_year = [1_958, 3_196, 4_919]
        own_year_consumption = consumption_per_year[self.inhabs-1]
        own_day_consumption = own_year_consumption/365.25
        hourly_consumption = own_day_consumption/24
        actual_consumption = 0
        if(ambient.is_night()):
            actual_consumption = hourly_consumption*0.25
        else:
            actual_consumption = hourly_consumption*1.75
        return actual_consumption

    def get_state(self) -> int:
        """The state of the building with only important information.

        Returns:
            list: 1 for did not have to import energy, 0 for did have to import energy
        """
        state = 0
        if(self.power_consumption() < self.get_power()):
            state = 1
        return [state]

    def receive_power(self, power: float):
        """Power given to the Building for use in the time step

        Args:
            power (float): given power
        """
        self.hourly_power_given += power

    def step(self):
        """Performs a time step for the building.
        Checks if energy needs to be bought and resets given power.
        """
        bought_power = 0
        # Has to buy power
        pw = self.power_consumption()
        if(self.hourly_power_given+self.battery.get_fuel() < pw):
            pw -= self.hourly_power_given
            pw -= self.battery.get_power(pw)
            bought_power = self.ambient.buy_energy(pw)
        # Loads battery with excess power
        elif(self.hourly_power_given > pw):
            self.battery.set_power(self.hourly_power_given-pw)
        # Does not need to buy power
        else:
            pw -= self.hourly_power_given
            self.battery.get_power(pw)
        self.hourly_power_given = 0
        # Save bought power amount in queue for rendering
        try:
            self.queue.put_nowait(bought_power)
        except qu.Full:
            pass

    def reset(self):
        """Resets the building and battery of the building
        """
        self.battery.reset()
        self.hourly_power_given = 0
        self.queue = qu.Queue()
